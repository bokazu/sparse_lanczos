# ランチョス法@COO形式疎行列


## 更新
- 2021/10/14 疎行列生成用のコードで乱数を実行ごとにリセットするのをわすれていたので、`srand(time(NULL))`を追加しました。


## ToDo
- [x] cblas_dgemvを自作のsparse_dgemvに置き換える。<br>
- [x] make_mat.cppを疎行列用のmake_mat.cppに置き換える。<br>
- [x] 使用済みの配列のメモリ解放を忘れない。<br>
- [ ] ベクトルuをn×nの配列ではなく、2×nの配列で計算を行えないかを考えてみる。<br>
- [ ] 固有値のファイル出力を横並びではなく、縦並びにする。<br>
- [ ] printmat,printvec系関数をtemplate機能を使って見やすくする。<br>
- [ ] 各コードの説明を書いたものを載せる。(md or pdf?)<br>
- [x] 固有ベクトルを求める。参考書のx[k] = \sum_{i=1}^m c_i v_i のv[i]は誤植でu[i]であることに注意
- [x] 参考書の「c_n = 1から出発し、c_{m-1}、c_{m-2}、...、c_{1}とさかのぼって求めるのが実際的である」とあるがこれは無視してよい。
- [x] 求めた固有ベクトルは最後に規格を忘れないように。
- [ ] 出力ファイルの様式を整える。
- [ ] ランチョスリスタートを実装する。
- [ ] CSR formatを実装する。 
- [ ] 疎行列構造可視化にトライする。


## 内容
COO形式の疎行列に対して、ランチョス法を適用し三重対角行列を作成、その後LAPACKにより固有値、固有ベクトルを求めるコードを作成した。ただし、
全ての固有値、固有ベクトルは求めず基底状態周辺のものについて求めた。
収束条件は、偶数回目と奇数回目で求めた基底状態の固有値の差が1.0e-15より小さければループ終了
というようにした。

## サンプル
注意)サンプル4,5は、`make_coo_mat.cpp`で`srand(time(NULL))`を忘れていたので行列構造が全く同じになっています。
- サンプル1(`sample/dns_sample0.txt`) 6×6行列
    以下のような6×6の実対称行列を用いた。
    ~~~
    6.0 5.0 4.0 3.0 2.0 1.0
    5.0 5.0 4.0 3.0 2.0 1.0
    4.0 4.0 4.0 3.0 2.0 1.0
    3.0 3.0 3.0 3.0 2.0 1.0
    2.0 2.0 2.0 2.0 2.0 1.0
    1.0 1.0 1.0 1.0 1.0 1.0
    ~~~
    これをCOO形式に直したファイルが`sample/coo_sample0.txt`である。<br>
    自分で書いたランチョス法により三重対角行列を使用、その後`dstev`に渡して固有値を求めた
    結果を`output/output0.txt`に出力した。また、密行列形式のものをそのまま`dsyev`に渡して固有値を求めた結果を`output/lapack_output0.txt`に出力した。<br>
    この2つの出力ファイルの結果を見比べると以下のようになる。
    ~~~
    #Eigen value of sample0
    #output0        #lapack_output0
    2.65187834e-01  2.65187834e-01
    3.18864384e-01  3.18864384e-01
    4.46214755e-01  4.46214755e-01
    7.74719222e-01  7.74719222e-01
    1.98815654e+00  1.98815654e+00
    1.72068573e+01  1.72068573e+01
    ~~~

    ~~~
    #Eigen vector of sample0
    #output0         #lapack_output0
    1.32748446e-01    1.32748446e-01
    -3.67834269e-01   -3.67834269e-01
    5.18653693e-01    5.18653693e-01
    -5.50655807e-01  -5.50655807e-01
    4.56509312e-01   4.56509312e-01
    -2.57782035e-01  -2.57782035e-01
    ~~~

- サンプル2(`sample/coo_sample1.txt`) 100×100行列
    詳しくは上記のファイルを参照すること。一部COO形式で行列要素を格納したファイルの情報を書くと
    ~~~
    100 100 3027
    0 5 1.0
    5 0 1.0
    0 8 1.0
    8 0 1.0
    ...
    ~~~
    である。つまり、今回10000個の行列要素のうち、3027個が1.0という値を持っている。
    自分で書いたランチョス法により三重対角行列を使用、その後`dstev`に渡して固有値を求めた
    結果を`output/output1.txt`に出力した。また、密行列形式のものをそのまま`dsyev`に渡して固有値を求めた結果を`output/lapack_output1.txt`に出力した。<br>
    この2つの出力ファイルの結果を見比べると以下のようになる。
    ~~~
    #Eigen value of sample1
    #output1        #lapack_output1
    -8.41872353e+00  -8.41872353e+00
    -8.11366592e+00  -8.11366592e+00
    -7.92846112e+00  -7.92846112e+00
    -7.59647424e+00  -7.59647424e+00
    ...
    ~~~

    ~~~
    #Eigen vector of sample1
    #output1          #lapack_output1
     2.78692260e-02   -2.78692284e-02
    -8.46607812e-02    8.46607839e-02
    -2.70093836e-02    2.70093823e-02
    -4.48258623e-02    4.48258631e-02
    -7.02582429e-02    7.02582411e-02
     2.19460239e-02   -2.19460220e-02
     1.63075169e-02   -1.63075178e-02
     5.23977848e-02   -5.23977869e-02
    -2.51975596e-01    2.51975597e-01
    -4.50211072e-02    4.50211058e-02
    ...
    ~~~

- サンプル4(`sample/coo_sample4.txt`) 1000×1000行列
    詳しくは上記のファイルを参照すること。一部COO形式で行列要素を格納したファイルの情報を書くと
    ~~~
    1000 1000 299504
    0 5 1.00000
    5 0 1.00000
    0 8 1.00000
    8 0 1.00000
    ...
    ~~~
    である。つまり、今回1000000個の行列要素のうち、約3割が値を持っている。
    自分で書いたランチョス法により三重対角行列を使用、その後`dstev`に渡して固有値を求めた
    結果を`output/output4.txt`に出力した。また、密行列形式のものをそのまま`dsyev`に渡して固有値を求めた結果を`output/lapack_output4.txt`に出力した。<br>
    この2つの出力ファイルの結果を見比べると以下のようになる。
    ~~~
    #Eigen value of sample4
    #output4        #lapack_output4
    -5.25004285e+00　-5.25004285e+00
    -5.20913142e+00　-5.20913142e+00
    -5.16293361e+00  -5.16293361e+00
    -5.10812671e+00  -5.10812674e+00
    -5.05478316e+00  -5.05845689e+00
    -5.02593325e+00  -5.03100672e+00
    -4.98837920e+00  -5.02611296e+00
    -4.92747528e+00  -5.00549170e+00
    -4.88115208e+00  -4.98512972e+00
    -4.84938992e+00  -4.93450111e+00
    ...
    ~~~

    ~~~
    #Eigen vector of sample4's ground state
    #output4         #lapack_output4
     1.70803908e-02   -1.70803959e-02
    -4.16210271e-02    4.16210328e-02
     7.23407412e-03   -7.23406642e-03
     2.51373840e-02   -2.51373685e-02
     3.98961282e-02   -3.98961474e-02
    -4.40787386e-02    4.40787305e-02
     4.30480808e-02   -4.30480809e-02
    -1.28468505e-02    1.28468491e-02
     5.46910410e-03   -5.46911735e-03
     3.92172540e-02   -3.92172523e-02
    ...
    ~~~
   
- サンプル5(`sample/coo_sample5.txt`) 1000×1000行列(non zero要素はすべて1.0)
    詳しくは上記のファイルを参照すること。一部COO形式で行列要素を格納したファイルの情報を書くと
    ~~~
    1000 1000 299504
    0 5 0.19755
    5 0 0.19755
    0 8 0.27777
    8 0 0.27777
    ...
    ~~~
    である。つまり、今回1000000個の行列要素のうち、約3割が値を持っている。
    自分で書いたランチョス法により三重対角行列を使用、その後`dstev`に渡して固有値を求めた
    結果を`output/output5.txt`に出力した。また、密行列形式のものをそのまま`dsyev`に渡して固有値を求めた結果を`output/lapack_output5.txt`に出力した。<br>
    この2つの出力ファイルの結果を見比べると以下のようになる。
    ~~~
    #Eigen value of sample5
    #output5        #lapack_output5
    -2.89660801e+01 -2.89660801e+01
    -2.86018315e+01 -2.86018315e+01
    -2.81599544e+01 -2.81599544e+01
    -2.79795595e+01 -2.79795646e+01
    -2.78492554e+01 -2.78533509e+01
    -2.77491597e+01 -2.77495791e+01
    -2.74614835e+01 -2.75023060e+01
    -2.72761920e+01 -2.74568966e+01
    -2.70840675e+01 -2.72960430e+01
    -2.65977532e+01 -2.71404448e+01
    -2.64359174e+01 -2.70776695e+01
    ...
    ~~~

    ~~~
    #Eigen vector of sample5's ground state
    #output5         #lapack_output5
     7.69730617e-03   -7.69730530e-03
    -5.53608931e-02    5.53608926e-02
    -5.69999535e-02    5.69999548e-02
     6.67249991e-02   -6.67249989e-02
     4.99459197e-02   -4.99459169e-02
    -1.05558985e-02    1.05558977e-02
    -5.36642451e-03    5.36642386e-03
    -5.04705830e-02    5.04705830e-02
    -5.18481962e-02    5.18481940e-02
     3.78330219e-02   -3.78330227e-02
    ...
    ~~~

## 各コードの説明
- `make_sparse_mat/make_coo_mat`
    ここで、COO形式の疎行列を作成する。ただし、LAPACKで行列を対角化したものと比較するためにDNS形式の行列も
    生成している。コードの正確性が保証されれば、DNS形式の行列生成部分は削除してもよい。<br>
    サンプルファイルの命名規則は以下のようにした。<br>
    - 疎行列COO形式 : `coo_sample(number).txt`
    - DNS形式 : `dns_sample(number).txt`
- `main.cpp`<br>
    ここで、サンプルファイルの読み込み、そしてランチョス法の実行を行う。
    計算結果はファイル形式で出力する。データファイルの命名規則は以下のようにした。
    - ランチョス法で三重対角行列を作成し、それをLAPACKに解かせた結果を出力したもの<br>
        ...output(number).txt   (number)の部分に適当な数字を命名する。
    - LAPACKで直接対角化させた結果<br>
        ...lapack_output(number).txt
- `inputdata.cpp`<br>
    このファイルの中には3つの関数のコードがある。主に、サンプルファイルに記録した行列データの抽出用の関数である。
    - `void get_matrix_size(string filename, int &n, int &elements)`<br>
        ...この関数はCOO形式で出力したサンプルファイルから行列の次元、非ゼロの要素数を読み取る。まずは、これでサイズの情報をゲットし、それをもとに配列のメモリを確保する。
    - `void input_coo_data(string filename, int elements, int *row, int *col,double *val)`<br>
        この関数は疎行列をCOO形式で出力したファイルのrow、col、valの情報を抽出する。
    -  `void input_dns_data(string filename, int n, double *A)`<br>
        この関数はDNS形式で行列情報を出力したファイルからデータを読み取る。
- `printmat.cpp`<br>
    このファイルには行列、ベクトルを整理した形で出力するための関数がある。ここでは、関数の説明を個別にすることはしないが、命名規則を紹介する。
    - `printmat_Type(int n, Type A)`<br>
        これはコマンドライン上に行列をN×N形式で出力する。
    - `fprintmat_Type(FILE file,int n, double* A)`<br>
        これはoutputファイルに行列をN×N形式で出力する。
    - `printve_Type(int n, Type *B)`<br>
        これはコマンドライン上にベクトルを出力する。
    - `fprintvec_Type(int n, Type *B)`<br>
        これはoutputファイルにベクトルを出力する。
- `gso.cpp`<br>
    - グラム-シュミットの直行化を行うための関数とベクトルの規格化を行うための関数が入っている。
    - `void gso(int n, int k, double** u)`<br>
        グラム・シュミットの直行化を行うための関数である。
    - `sdz (int n, double* v)`<br>
        ベクトルの規格化を行う。
- `vec_Initialize.cpp`<br>
    1次元配列の初期化を行うための関数のコードがある。
    - `void Initiailize_vec(int n, Type *vec)`<br>
        この関数は引数にとる配列の型で`int *vec`と`double *vec`でオーバーロードしている。
- `sparse_dgemv.cpp`<br>
    COO形式の疎行列とベクトルとの行列-ベクトル積を行うための関数が入っている。
    - `void sparse_dgemv(int n, int elements, double *v, int *row, int *col,
                  double *val, double *u)`<br>
        疎行列-ベクトル

    C++の知識が少なく関数が乱立した形になってしまっているが、最近これをもう少し整理した形で書くことができるかもしれない機能を知ったのであとで整理しようと思う。
            

## 注意
サンプルの行列は外部ファイルで作成し、本コードではそのファイルから数値を読み取って使用する。