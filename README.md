# ランチョス法@COO形式疎行列

## ToDo
- [x] cblas_dgemvを自作のsparse_dgemvに置き換える。<br>
- [x] make_mat.cppを疎行列用のmake_mat.cppに置き換える。<br>
- [x] 使用済みの配列のメモリ解放を忘れない。<br>
- [ ] ベクトルuをn×nの配列ではなく、2×nの配列で計算を行えないかを考えてみる。<br>
- [ ] 固有値のファイル出力を横並びではなく、縦並びにする。<br>
- [ ] printmat,printvec系関数をtemplate機能を使って見やすくする。<br>
- [ ] 各コードの説明を書いたものを載せる。(md or pdf?)<br>
- [ ] 固有ベクトルを求める。参考書のx[k] = \sum_{i=1}^m c_i v_i のv[i]は誤植でu[i]であることに注意
- [ ] 参考書の「c_n = 1から出発し、c_{m-1}、c_{m-2}、...、c_{1}とさかのぼって求めるのが実際的である」とあるがこれは無視してよい。
- [ ] 求めた固有ベクトルは最後に規格を忘れないように。


## 内容
COO形式の疎行列に対して、ランチョス法を適用し三重対角行列を作成、その後LAPACKにより固有値を求めるコードを作成した。

## サンプル
- サンプル1(`sample/dns_sample0.txt`) 6×6行列
    以下のような6×6の実対称行列を用いた。
    ~~~
    6.0 5.0 4.0 3.0 2.0 1.0
    5.0 5.0 4.0 3.0 2.0 1.0
    4.0 4.0 4.0 3.0 2.0 1.0
    3.0 3.0 3.0 3.0 2.0 1.0
    2.0 2.0 2.0 2.0 2.0 1.0
    1.0 1.0 1.0 1.0 1.0 1.0
    ~~~
    これをCOO形式に直したファイルが`sample/coo_sample0.txt`である。<br>
    自分で書いたランチョス法により三重対角行列を使用、その後`dstev`に渡して固有値を求めた
    結果を`output/output0.txt`に出力した。また、密行列形式のものをそのまま`dsyev`に渡して固有値を求めた結果を`output/lapack_output0.txt`に出力した。<br>
    この2つの出力ファイルの結果を見比べると以下のようになる。
    ~~~
    #output0        #lapack_output0
    2.65187834e-01  2.65187834e-01
    3.18864384e-01  3.18864384e-01
    4.46214755e-01  4.46214755e-01
    7.74719222e-01  7.74719222e-01
    1.98815654e+00  1.98815654e+00
    1.72068573e+01  1.72068573e+01
    ~~~

- サンプル2(`sample/coo_sample1.txt`) 100×100行列
    詳しくは上記のファイルを参照すること。一部COO形式で行列要素を格納したファイルの情報を書くと
    ~~~
    100 100 3027
    0 5 1.0
    5 0 1.0
    0 8 1.0
    8 0 1.0
    ...
    ~~~
    である。つまり、今回10000個の行列要素のうち、3027個が1.0という値を持っている。
    自分で書いたランチョス法により三重対角行列を使用、その後`dstev`に渡して固有値を求めた
    結果を`output/output0.txt`に出力した。また、密行列形式のものをそのまま`dsyev`に渡して固有値を求めた結果を`output/lapack_output.txt`に出力した。<br>
    この2つの出力ファイルの結果を見比べると以下のようになる。
    ~~~
    #output1        #lapack_output1
    -8.41872353e+00  -8.41872353e+00
    -8.11366592e+00  -8.11366592e+00
    -7.92846112e+00  -7.92846112e+00
    -7.59647424e+00  -7.59647424e+00
    ...
    ~~~

## 各コードの説明
- `make_sparse_mat/make_coo_mat`
    ここで、COO形式の疎行列を作成する。ただし、LAPACKで行列を対角化したものと比較するためにDNS形式の行列も
    生成している。コードの正確性が保証されれば、DNS形式の行列生成部分は削除してもよい。
    サンプルファイルの命名規則は以下のようにした。
    - 疎行列COO形式 : `coo_sample(number).txt`
    - DNS形式 : `dns_sample(number).txt`
- `main.cpp`
    ここで、サンプルファイルの読み込み、そしてランチョス法の実行を行う。
    計算結果はファイル形式で出力する。データファイルの命名規則は以下のようにした。
    - ランチョス法で三重対角行列を作成し、それをLAPACKに解かせた結果を出力したもの
        ...output(number).txt   (number)の部分に適当な数字を命名する。
    - LAPACKで直接対角化させた結果
        ...lapack_output(number).txt
- `inputdata.cpp`
    このファイルの中には3つの関数のコードがある。主に、サンプルファイルに記録した行列データの抽出用の関数である。
    - `void get_matrix_size(string filename, int &n, int &elements)`
        ...この関数はCOO形式で出力したサンプルファイルから行列の次元、非ゼロの要素数を読み取る。まずは、これでサイズの情報をゲットし、それをもとに配列のメモリを確保する。
    - `void input_coo_data(string filename, int elements, int *row, int *col,double *val)`
        この関数は疎行列をCOO形式で出力したファイルのrow、col、valの情報を抽出する。
    -  `void input_dns_data(string filename, int n, double *A)`
        この関数はDNS形式で行列情報を出力したファイルからデータを読み取る。
            

## 注意
サンプルの行列は外部ファイルで作成し、本コードではそのファイルから数値を読み取って使用する。